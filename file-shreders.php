<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="wp-content/themes/dc8044/favicon.ico">

    <title>DC8044 Guide</title>

    <link href="wp-content/themes/dc8044/bootstrap.min.css" rel="stylesheet">
    <link href="wp-content/themes/dc8044/style.css" rel="stylesheet">
</head>

<body class="guide-page">
<div class="guide-body">
    <div class="page_title">
        <h2>
            Файловые шредеры
        </h2>
    </div>
    <p>
        Добрый день, дорогие любители малвари. Мы начинаем обзор техник и технологий, который часто применяются во всяких зловредах. Если статья будет принята читателями хорошо, мы постараемся не останавливаться на достигнутом и делать обзоры чаще.
    </p>
    <p>
        Сегодня мы поговорим о такой вещи, как файловые шредеры. Файловый шредер, по аналогии с офисной оргтехникой, реализует безвозвратное удаление файлов с диска. Обычные API операционной системы удаляют файлы, но делают это максимально быстро. Потому фактически информация просто становится недоступной, но не удаляется физически. Следовательно, может быть восстановлена специальными утилитами.
    </p>
    <p>
        Ну и что с того? А то, что в мире малвари эти штуки (шредеры) имеют важное практическое значение. Давайте рассмотрим пару сценариев, где они могут быть востребованы.
    </p>
    <p>
        Сценарий 1. Один ваш друг (конечно же, не вы сами, а друг) разрабатывал некое зловредное ПО. В какой-то момент к нему пришли «маски-шоу» и очень хотят изъять технику для криминалистического анализа. Чтобы криминалисты не нашли там неугодных файлов, ваш товарищ решает их удалить. Вот тут-то ему и понадобится файловый шредер, чтобы удалить всё безвозвратно.
    </p>
    <p>
        Сценарий 2. Вы анализируете криптолокер. Криптолокер зашифровал ваши файлы, и вас интересует, есть ли возможность восстановить зашифрованные данные. Если выясняется, что использовались стойкие алгоритмы шифрования, и ключ для расшифровки вычислить невозможно (за разумное время), то стоит присмотреться, а действительно ли с диска удалено оригинальное содержимое? Такие знания пригодятся и при написании криптолокеров, но этого мы, конечно, делать не рекомендуем.
    </p>
    <p>
        Само собой, проблема не нова, и существуют готовые решения. Но нас интересует именно программная реализация, т.е. как самостоятельно написать такое или как оценить качество чужого кода. Для начала, давайте рассмотрим opensource решение на python. Код взят <a href="https://github.com/bleachbit/bleachbit/blob/master/bleachbit/FileUtilities.py" class="link" target="_blank">отсюда</a>.
    </p>
    <p>
        Простое и безопасное удаление данных выглядит вот так:
    </p>

    <div class="code_block">
        def wipe_write():
        &#9;size = getsize(path)
        &#9;try:
        &#9;&#9;f = open(path, 'wb')
        &#9;except IOError as e:
        &#9;if e.errno == errno.EACCES:  # permission denied
        &#9;&#9;&#9;os.chmod(path, 0o200)  # user write only
        &#9;&#9;&#9;f = open(path, 'wb')
        &#9;&#9;else:
        &#9;&#9;&#9;raise
        &#9;blanks = chr(0) * 4096
        &#9;while size > 0:
        &#9;&#9;f.write(blanks)
        &#9;&#9;size -= 4096
        &#9;f.flush()  # flush to OS buffer
        &#9;os.fsync(f.fileno())  # force write to disk
        &#9;return f
    </div>

    <p>
        Но нас интересует, можно ли как-то ускорить процесс удаления файлов (в случае, если их много, а времени – не очень), и насколько полным такое удаление является.
    </p>
    <p>
        Давайте по порядку. Введение в тему может дать это <a href="https://www.youtube.com/watch?v=O0Q_OTWHiCY" class="link" target="_blank">видео</a>.
    </p>
    <p>
        Правда, стоит заметить, что некоторые вещи там слегка упрощены, некоторые моменты не описаны вовсе (что в целом нормально для ограниченного по времени выступления). Кроме того, описание стандартов перезаписи хоть и существует, но разнится с другими
        <a href="https://habr.com/ru/post/264429/" class="link" target="_blank">источниками</a>.
    </p>
    <p>
        На данном этапе чтения вы должны были ознакомится с предложенными видео и статьей, и теперь прекрасно понимаете такие вещи:
    </p>
    <ol>
        <li>
            Программное удаление данных достигается их перезаписью.
        </li>
        <li>
            Стандарты регламентируют определённые правила перезаписи (т.е. нужно перезаписывать информацию определённое количество раз и определёнными паттернами).
        </li>
        <li>
            Надёжное удаление данных можно гарантировать только при полном уничтожении носителя.
        </li>
    </ol>

    <p>Из этого следуют несколько важных выводов. </p>

    <ol>
        <li>
            Действительно важные данные лучше хранить в облаке. Например, у правоохранительных органов могут возникнуть проблемы с физическим доступом к устройству, когда оно находится где-нибудь в дата-центре на территории Китая.
        </li>
        <li>
            Избавляйтесь от валяющихся флешек, карт памяти, старых дисков, (если они уже не используются), потому что мало ли что на них когда-то было записано. Разумеется, к нормально функционирующим устройствам этот пункт не относится.
        </li>
        <li>
            Нам нужен код, который может эффективно и надёжно перезаписывать фалы перед их удалением.
        </li>
    </ol>

    <p>
        Сперва определимся с алгоритмом перезаписи. Для примера возьмём описанный в статье с хабра (ссылка выше) алгоритм:
    </p>

    <div class="code_block">
        AFSSI S020 (стандарт ВВС США) — первый цикл — все «0», затем все «F», затем псевдослучайные числа, а затем верификация 10% перезаписанных данных.
    </div>

    <p>
        Если с первым и вторым циклами перезаписи всё очевидно, то в третьем цикле, в качестве генератора случайных чисел, используем
        <a href="https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom" class="link" target="_blank">API ОС Windows</a>.
    </p>
    <p>
        Каждая операционная система обладает похожими API, потому мы не будем останавливаться на этом подробно. Остаётся верификация. О ней мы поговорим подробнее немного позже.
    </p>
    <p>
        Итак, выходит, что стирание включает в себя:
    </p>

    <ol>
        <li>
            Перезапись байтами 0х00.
        </li>
        <li>
            Перезапись байтами 0xFF.
        </li>
        <li>
            Перезапись псевдослучайными байтами, сгенерированными криптостойкими API.
        </li>
        <li>
            Удаление такого перезаписанного файла через доступные API.
        </li>
    </ol>

    <p>
        Ну что же – с алгоритмом мы разобрались. Теперь уточним некоторые детали перед продолжением повествования. В ранее упомянутом видео докладчик показывает окно шестнадцатеричного редактора и говорит, что вот так выглядит файл. На самом деле, всё немного сложнее. У дисков есть понятие сектора и кластера. Сектор – это аппаратно адресуемый блок, т.е. минимальная единица хранения данных на диске. Это некое подобие страницы виртуальной памяти в адресном пространстве процесса. Файловые системы работают с кластерами. Т.е. кластер состоит из нескольких секторов.
    </p>
    <p>
        Маленькие файлы вполне могут размещаться в пределах одного сектора. Тогда ситуация будет такой, как на картинке в докладе. Тем не менее, большие файлы могут занимать далеко не один кластер, и кластеры могут быть разбросаны по диску (размещаться не по порядку друг за другом).  И такой диск может быть открыт шестнадцатеричным редактором, или же программно,  вот так:
    </p>

    <div class="code_block">
        …приходится прибегать к услугам функции <span class="red">CreateFile</span>.
        Если вместо имени открываемого файла указать название устройства, например, <span class="red">\\.\PHYSICALDRIVE0</span> (первый физический диск),
        мы сможем свободно читать и записывать его сектора вызовами <span class="red">ReadFile</span> и <span class="red">WriteFile</span> соответственно.
        При этом флаг <span class="red">dwCreationDisposition</span> должен быть установлен на значение <span class="red">OPEN_EXISTING</span>,
        а флаг <span class="red">dwShareMode</span> — на значение <span class="red">FILE_SHARE_WRITE</span>.
        Еще потребуются права системного администратора, иначе ничего не получится…
    </div>

    <p>
        Цитата отсюда: <a href="http://www.you-books.com/book/K-Kasperski/Vosstanovlenie-Dannyh-Prakticheskoe-Rukovodstvo" class="link" target="_blank" >you-books.com</a>.
    </p>
    <p>
        Но правда в том, что операционные системы или языки программирования предоставляют более удобные механизмы работы с файлами, благодаря которым можно предполагать, что их (файловое) содержимое располагается в некоем условном непрерывном блоке памяти. Зачем нам информация о секторах и кластерах? Она пригодится нам на этапе верификации. До него мы ещё дойдём, а пока будет полезно держать перед собой вот такую картинку:
    </p>
    <div class="landing_img"><img src="wp-content/themes/dc8044/photo_2019-07-25_14-16-57.jpg" alt=""/></div>
    <p>
        Очевидно, что помимо данных самого файла, файловая система хранит его метаданные: имя, атрибуты и иную служебную информацию. И эту информацию так просто переписать не выйдет. Но нужно ли нам её переписывать? И, если нужно, то всю, или какую-то её часть?
    </p>
    <p>
        Если мы говорим про криптолокер, то его задача – заменить оригинальный контент зашифрованным содержимым. Имя и атрибуты как раз нужно оставить без изменений. В таком контексте метаданные нам мало интересны.
    </p>
    <p>
        Но что если мы удаляем исходники какого-то зловредного ПО? Хотелось бы еще и имена стереть, помимо содержимого. Согласитесь, будет очень подозрительно, если аналитик найдёт записи с такими именами:
    </p>

    <ul>
        <li>CryptoLocker.py</li>
        <li>BootloaderInjector.cpp</li>
        <li>InfectorPE32.java</li>
    </ul>

    <p>
        Потому перед удалением файлы надо переименовать. Для этого в ОС Windows есть
        <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefile" class="link" target="_blank">API MoveFile</a>.
    </p>
    <p>
        От нас требуется сгенерировать имя той же длины, что и у оригинала, но из случайных символов.
    </p>
    <p>
        Ещё один нюанс – это способ доступа к содержимому файла. Вместо обычного последовательного чтения/записи мы будем использовать файловые проекции. Дело в том, что в ОС семейства Linux файловый мэппинг не даёт выигрыша в скорости, а вот на ОС Windows – выигрыш значительный. Но необходимо учесть наличие больших файлов, размер которых превышает 4 Гб. Такие файлы однозначно не могут быть спроецированы на адресное пространство 32-битной ОС, а потому их придётся проецировать частями.
    </p>
    <p>
        Теперь по поводу проверки (верификации). Здесь мы поступим иначе, чем было описано в статье с хабра. Там предлагается проверять некий процент файлового перезаписанного контента (например, 10 %), т.е. мы должны сгенерировать случайные данные, сохранить их, а потом заново считывать файл и проверять, являются ли вновь считанные данные теми самыми случайными значениями. Очевидно, что это условие будет выполняться и для копии файла. Например, если у нас был файл a.txt, потом мы сделали его копию с именем b.txt, и затем попытались перезаписать b.txt. Считывание и проверка данных из b.txt никак не покажет нам, что у нас есть оригинальный контент в a.txt. Потому для проверки мы все-таки применим другой способ.
    </p>
    <p>
        Дело в том, что нас интересует, не изменилось ли физическое расположение файла на диске. Не стал ли его контент занимать другие сектора и кластеры? Ведь если это произошло, значит ранее используемые сектора могут по-прежнему содержать оригинальный контент, который не будет перезаписан. Для того, чтобы получить информацию о физическом расположении файла на диске, в ОС Windows у нас уже есть всё необходимое. Драйвера файловых систем поддерживают возможность обработки IRP пакетов, которые могут создаваться по запросу
        <a href="https://docs.microsoft.com/ru-ru/windows/win32/api/winioctl/ni-winioctl-fsctl_get_retrieval_pointers" class="link" target="_blank">API из режима пользователя</a>.
    </p>
    <p>
        Таким образом, нам нужно получить дескриптор файла, и передать его функции DeviceIoControl. Более подробно с реализацией можно ознакомиться <a href="https://bitbucket.org/KulykIevgen/fileshredder/" class="link" target="_blank">тут</a>.
    </p>
    <p>
        Для сборки вам понадобится Microsoft Visual Studio, я использовал 2019 Community. Скрипт build.ps1 будет работать, если
        <a href="https://docs.microsoft.com/ru-ru/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6" class="link" target="_blank">исполнение скриптов разрешено</a>.
    </p>

    <div class="author">by ARCHANGEL</div>
</div>


<footer>
    <a href="index.php" class="link_main">
        MAIN PAGE
    </a>
    <img src="wp-content/themes/dc8044/X_pic.png" alt="" class="img-fluid main_img">

</footer>
</body>
</html>
